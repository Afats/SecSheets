# Binary Memory Protections

As memory corruption vulnerabilities and binary exploitation became more and more common compiler and operating system engineers began inventing inbuilt protection schemes to reduce the harm cause by poor programming choices. Ever since there has been a constant battle between attackers sidestepping protections and patchers trying to add new mitigation's to make vulnerabilities more difficult to exploit.


## Address Space Layout Randomization (ASLR) 

* ASLR is a kernel level protection enabled by default on most modern operating systems
* ASLR is not a protection implemented by the compiler
* ASLR works with a ASLR slide which is a random offset that shifts key areas of process address space by that amount
* Regions of interest that are shifted include: 
    * The stack 
    * The executables base 
    * Libraries (libc)
    * The heap
* The implication of ASLR for binary exploitation is that it typically makes the process of jumping from an overflown return pointer to somewhere else in the binary such as attacker shellcode or libc a task of guesswork as the start of these regions shift randomly 
* On 32 bit systems the chances of guessing a desired place to return are significantly better than 64 bit systems
* Under certain conditions the probability of guessing a correct address particularly on the stack are greatly increased 
* See [circumventing ASLR](#)

## Stack Canaries

* A stack canary or stack cookie can manifest in two ways 
* Firstly as a custom implementation by the programmer and secondly as a protection implemented by the compiler 
* In both cases the stack canary sits just before (4 bytes 32bit 8 bytes 64bit) each functions return pointer in this way if an attacker attempts to overflow up to the return pointer with arbitrary padding the value of the canary will be damaged causing a function which checks for the integrity of the stack canary before the return to exit early thus avoiding the return to a potentially dangerous area in memory  
* Custom implementations can often be trivially avoided by leaking the value off the stack or in the case of a hardcoded value be trivially discovered through decompolation of the binary 
* Official compiler based stack canaries like the ones gcc implements are more difficult to negate, an attacker can either attempt to brute force / guess the cookie value, which is feasible in 32 bit ecosystems, or leak the cookie value using another vulnerability such as a format string 
* See [circumventing stack canaries](#)

## Non-Executable stack (NX)

* The NX or NoExecute bit is a compiler level protection that makes the stack region of a processes address space non executable 
* This mitigation makes it difficult for an attacker to execute shellcode placed onto the stack even with control of the return pointer 
* See [circumventing NX](#) 

## Relocation Read-Only (RELRO)

* RELRO is another compiler level protection scheme which makes certain regions of a processes address space read only 
* In this way it is quite similar to NX on steroids
* RELRO has to modes
* Full RELRO makes anything that can be read-only read-only including the GOT table 
* Partial RELRO makes a few things read only such as the stack but still allows writes to places like the GOT 
* See [circumventing RELRO](#) 

## Position Independent Executable (PIE)

* PIE is a yet another compiler level protection scheme but unlike the others it is tied to the presence of ASLR, without ASLR pie is automatically disabled 
* Similarly to ASLR the addresses of many things in the processes address space a shifted by some offset but unlike ASLR which maintains a stable ordering of regions PIE allows for regions to appear in any order relative to each other 
* It is important however to note that items within The same region will maintain the safe offset to each other per execution 
* PIE had very similar goals to ASLR but is almost certainly more difficult to circumvent ordinarily due to the property that regions can appear in completely different order each time the process executes 
* For an attacker the goal is to be able to leak some address while the process is executing that will provide the necessary context to calculate offsets to useful memory segments within the leaked region 
* See [Circumventing PIE](#) 