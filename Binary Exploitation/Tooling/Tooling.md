# Tooling

Tooling in modern day exploitation is crucial, as systems become increasingly complex we need a way to interpret information in useful and readable formats as well as interact with such systems in a scripted way.


## Decompilers and Disassemblers

+ [**Binaryninja**](https://binary.ninja/)
    + Probably one of the best decompiler/disassembler combinations out there in terms of the user experience and power
    + Free 25 minute demo or 'relatively' cheap one off purchase licence 
+ [**IDA Pro**](https://hex-rays.com/IDA-pro/)
    + Arguably the most powerful decompilers on the market, affordable only to companies tho ...
+ [**IDA Free**](https://hex-rays.com/ida-free/)
    + The sadder version of IDA pro, not that good
    + Has a cloud version now which is okay
+ [**Cutter**](https://cutter.re)
    + A free open source decompiler/disassembler combination that most closely resembles Binaryninja
    + Has great potential but often falls short due to poor analysis of strings and stuff
    + Has quite a few [plugins](https://github.com/rizinorg/cutter-plugins) available tho

## Debuggers

+ [**pwndbg**](https://pwndbg.re/)
    + Check out my [.gdbinit](./Templates/.gdbinit) file
+ [**peda**](https://github.com/longld/peda)
+ [**GEF**](https://gef.readthedocs.io/en/master/)


## [Exploit Writing](./PwntoolsCheatsheet.md)

+ For a separate file of this section see [pwntools cheatsheet](./PwntoolsCheatsheet.md)

### Overview

```python
from pwn import *
```

### [Template Script](./Templates/pwn.py)

```python
#!/usr/bin/python3

# Switches
from re import S
import sys
import argparse

# pretty print
import pprint
from colorama import Fore, Style
pp = pprint.PrettyPrinter(indent=4)

# pwn
from pwn import *
from pwnlib.rop import gadgets


# fmt
from formatstrings.fmt_string import build


# ::::::::::::::::::::::::: CONFIG :::::::::::::::::::::::::
PATH = 'Chals'
BINARY = '_binary_'
HOST = '_domain_:_port_'

LIBC_REMOTE = f'{PATH}/libc/libc-2.23.so'
LIBC_LOCAL = '/usr/lib/i386-linux-gnu/libc-2.33.so'
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# ::::::::::::::::::::::: CHECK SEC ::::::::::::::::::::::::

'''

'''

# ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


def pwn(args):
    """ hack the program """
    binary = f'./{PATH}/{BINARY}'
    proc = process(binary)
    rop = ROP(binary)
    elf = ELF(binary, False)
    libc = ELF(LIBC_LOCAL, checksec=False)

    if (args.remote):
        host = HOST.split(':')
        proc = remote(host[0], int(host[1]))
        try: libc = ELF(LIBC_REMOTE, checksec=False)
        except: libc = None
    if (args.debug): gdb.attach(proc)
    if (args.gadgets):
        gadgets = rop.gadgets
        pp.pprint(gadgets)
    if (args.ret2libc): rop = ROP(libc)


    ## get da banner
    log.info('Receiving banner ...')
    # proc.recvuntil('> ')


    # shellit
    proc.interactive()



def print_banner():
    print(Fore.GREEN + '''
  __                              
  \ \   _ ____      ___ __       
   \ \ | '_ \ \ /\ / / '_ \       
   / / | |_) \ V  V /| | | |     
  /_/  | .__/ \_/\_/ |_| |_|     
       |_|                       
                              
    ''')
    print(Style.RESET_ALL)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description=print_banner(), 
        epilog='>> happy pwning'
    )

    parser.add_argument('-l', '--local',
                        help = 'run against local binary, default',
                        action = 'store_true',
                        )
    parser.add_argument('-d', '--debug',
                        help = 'run with debugger attached',
                        action ='store_true'
                        )
    parser.add_argument('-r', '--remote',
                        help = 'run against remote binary',
                        action ='store_true'
                        )
    parser.add_argument('-g', '--gadgets',
                        help = 'dump binary gadgets',
                        action ='store_true'
                        )
    parser.add_argument('-libc', '--ret2libc',
                        help = 'configure rop for ret2libc',
                        action ='store_true'
                        )

    args = parser.parse_args()

    if (len(sys.argv) == 1): parser.print_help()
    else: pwn(args)
```


### Common Tasks

#### Making Connections

```python
# local
# proc = process('./<binary>')
proc = process('./challenge1')

# remote
# proc = remote('domain.com', port)
proc = remote('hackme.com', 2048)
```

#### Passing Banners

```python
# proc.recvuntil('some string/pattern')
proc.recvuntil('welcome to the challenge, please enter a name: ')
```

#### Sending data

```python
# proc.sendline(payload)
proc.sendline(b'A' * 42)
```

#### Catching Shells

```python
proc.interactive()
```

#### Finding Offsets

```python
test_buffer_len = 42
test_offset = cyclic(test_buffer_len)
# >> test_offset = b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaaka'

# the byte sequence that overwrote the return pointer
eip_overwritten_bytes = b'aaah'
offset = cyclic_find(eip_overwritten_bytes)
# >> offset = 25
```

#### Packing Addresses

```python

# p32(0xaddress)
return_ptr = p32(0x08048536)
```

#### Unpacking Addresses

```python
# u32(b'byte-sequence')
str_bytes = u32(b'abcd')
```

#### Shellcode

```python
"""
shellcode = asm('''
    x86 instructions
''')
"""

shellcode += asm('''
	xor ebx, ebx

    mov eax, SYS_read
    mov ebx, 0x3e8
    mov ecx, esp
    mov edx, 0xbe
    int 0x80

    mov eax, SYS_write
    mov ebx, 0x1
    mov edx, 0xbe
    mov ecx, esp
    int 0x80
''')
```

#### ELF Hooks

```python

elf_binary = ELF('./<binary>')

win_addr = hex(elf_binary.symbols['win'])

printf_got_addr = hex(elf_binary.got['printf'])

printf_plt_addr = hex(elf_binary.plt['printf'])
```

#### Fit/Flat

+ Quickly build payload which automatically adjusts for specified padding length

```python
# fills the length amount of bytes with garbage padding
payload = fit({
    0x6c-0xc: p32(canaryValue),
    0x6c: p32(elf.symbols['win'])
}, length=0x6c + 4)   # -> padding

p.sendline(payload) # whoo
p.interactive()

```

+ combo it

```python
payload = fit({
    0x6c-0xc: p32(canaryValue),
    0x6c: p32(elf.symbols['win'])
}, length=cyclic_find(b'aala'))   # -> padding

p.sendline(payload)
p.interactive()
```


### Logging & Debugging

#### Debug mode

```shell
$ python3 exploit.py DEBUG
```

#### Detailed Logs

```python
context.log_level = 'debug'
```

#### Custom Logs

```python
log.info(f'Win @ {win_addr}')
```

#### Logging Off

```python
logging.disable()
```
